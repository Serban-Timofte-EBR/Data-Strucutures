CURS 2 - Structuri de Date

Structura NODE: 

struct Node {
    int data;
    struct Node* next;
};

Lista va ocupa mai multa memorie fata de vector pentru ca stocam si adresa urmatorului element

Memoria STACK: 

    - Variabile locale, temporare, etc
    - Nu o putem folosi decat pentru ce am gandit initial cand a fost facut programul
    - Este un spatiu limitat => avem probleme la redimensionare
    - Este o structura de data STIVA - LIFO

Memoria HEAP:

    - Alocare de memorie pe durata de executie a aplicatiei
    - Alocare gestionata de OS
    - Memorie alocata dinamica ( pana la pointerul break )
    - Responsabilitatea pentru dezalocare => memory leaks

Clase de memorie variabile:

    - AUTOMATICE:
        - auto 
        - var. locale
        - stocate in STIVA
        - auto a = 7;
    
    - REGISTRU: 
        - var. locale, param. funcitie
        - vor rezista pana la finalul blocului de executie
        - register int vreg;

    - EXTERNE:
        - folosite in fisiere sursa
        - persistente pana la finalul blocului
        - pentru a folosi in mai multe fisiere sursa si pentru a le putea folosi. Un i este folosit si intr-un prim fisier si intr-un al doilea fisier

    - STATICE
    
TIPURI DE DATE:

    - Fundamentale
    - Definite de utilizatori
    - malloc + free pentru alocare si dezalocare

LISTA SIMPLA: 

    - o colectie de noduri ( blocuri de memorie separate alocate la adrese distincte )
    - se construieste progresiv
        - functie pentru crearea unui nod
            - un nod are o zona dedicata continutului si una pentru pointerului de legatura
            - adresa urmatoare va fi initializata cu NULL
            - daca am lista de articole: memorie = sizeof(articol) + 4
            - daca am lista de pointeri la articole: memorie = 8 bytes
    - avem doar parcurgere secventiala, adresa primului nod si se parcurge prin adresele de legatura
    - este alocata complet in HEAP

    - AVANTANJUL listei vs vector: putem folosi lista fara sa stim numarul de elemente initial
        - adresele nodurilor din lista nu sunt neaparat consecutive
        - adresele la vectori sunt contigue
    
    IMPLEMENTARE:
        - prin nod cu valoarea si adresa de legatura
        - lista simpla = un singur pointer de legatura ( catre urmatorul element ) => nu pot sa parcurg de la coada la cap
        - ultimul nod nu are adreasa de legatura

        typedef struct {
            char inf;
            struc Nod* next;
        } Nod;

        Nod* prim = NULL;   //declarare initiala

        //noul nod
        Nod* nou = (Nod*)malloc(sizeof(Nod));
        nou->inf = 'A';
        
        typedef struct {
            produs inf;
            struc node* next;
        } node;

        node* inserare(node* cap, produs p) {
            // aloc memorie pentru noul nou
            node* nou = (node*)malloc(sizeof(node));

            //initializez nodul cu valorile pe care le vreau din p
            nou->inf.cod = p.cod;
            nou->inf.denumire = (char*)malloc((strlen(p.denumire) + 1) * sizeof(char));
            strcpy(nou->inf.denumire, p.denumire);
            nou->inf.pret = p.pret;
            nou->inf.cantitate = cantitate;
            //!!! Pointerul nodului este NULL !!!
            nou->nest = NULL;

            if(cap == NULL) {
                cap = nou;
            }

            else {
                //accesul secvential, parcurgerea listei simple
                node* temp = cap;
                while(temp->next != NULL) {
                    temp = temp->next
                }
                temp->next = nou;
            }
            return cap;
        }

        cap = inserare(cap, p); //apelare in main

    PARCURGERE = TRAVERSARE

        void traversare(node* cap) {
            node* temp = cap;
            while(temp->next != NULL) {
                //afisare produsului
                temp = temp->next
            }
        }

    DEZALOCARE:

        node* temp = cap;
        while(temp != NULL) {
            node* temp2 = temp->next;
            free(temp->inf.denumire);
            free(temp);
            temp = temp2; // echivalentul temp = temp->next, dar cu noua variabila;
        }

LISTA DUBLA:

    - avem inca un pointer catre prov

    typedef struct {
        char inf;
        struct NodD* prev, next;
    } NodD*

    //declarare
    ListaD lst;
    lst.prim = NULL;
    lst.ultim = NULL;

    //alocare de memorie in heap pentru un nod al listei duble
    NodD* nou = (NodD*)malloc(sizeof(NodD));

    typedef struct{
        produs* p;
        struct nodels *next, *prev;
    } nodels

    nodels* inserare (nodels* cap, nodls** coada, produs* p) {  //coada se modifica, dar nu se returneaza
        //alocare de nod nou
        nodls* nou = (nodls*)malloc(sizeof(nodls));

        //pentru deep copy aloc in nodul nou un spatiu pentru produs, apoi in produs spatiu pentru cod si pentru denumire
        // *(nou->inf->cod) = *(p->cod);
        // strcpy(nou->inf->denumire, p->denumire);

        //copiere produs
        nou->inf = p; //shallow copy
        nou->next = NULL;
        nou->prev = NULL;

        if(cap == NULL) {
            cap = nou;
            *coada = nou;
        }

        else {
            nodels* temp = cap;
            while(temp->next != NULL) {
                temp = temp->next;
            }
            nou->prev = temp;
            *coada = nou;
        }
    }